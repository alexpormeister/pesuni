revoke delete on table "public"."coupons" from "anon";

revoke insert on table "public"."coupons" from "anon";

revoke references on table "public"."coupons" from "anon";

revoke select on table "public"."coupons" from "anon";

revoke trigger on table "public"."coupons" from "anon";

revoke truncate on table "public"."coupons" from "anon";

revoke update on table "public"."coupons" from "anon";

revoke delete on table "public"."coupons" from "authenticated";

revoke insert on table "public"."coupons" from "authenticated";

revoke references on table "public"."coupons" from "authenticated";

revoke select on table "public"."coupons" from "authenticated";

revoke trigger on table "public"."coupons" from "authenticated";

revoke truncate on table "public"."coupons" from "authenticated";

revoke update on table "public"."coupons" from "authenticated";

revoke delete on table "public"."coupons" from "service_role";

revoke insert on table "public"."coupons" from "service_role";

revoke references on table "public"."coupons" from "service_role";

revoke select on table "public"."coupons" from "service_role";

revoke trigger on table "public"."coupons" from "service_role";

revoke truncate on table "public"."coupons" from "service_role";

revoke update on table "public"."coupons" from "service_role";

revoke delete on table "public"."driver_calendar_events" from "anon";

revoke insert on table "public"."driver_calendar_events" from "anon";

revoke references on table "public"."driver_calendar_events" from "anon";

revoke select on table "public"."driver_calendar_events" from "anon";

revoke trigger on table "public"."driver_calendar_events" from "anon";

revoke truncate on table "public"."driver_calendar_events" from "anon";

revoke update on table "public"."driver_calendar_events" from "anon";

revoke delete on table "public"."driver_calendar_events" from "authenticated";

revoke insert on table "public"."driver_calendar_events" from "authenticated";

revoke references on table "public"."driver_calendar_events" from "authenticated";

revoke select on table "public"."driver_calendar_events" from "authenticated";

revoke trigger on table "public"."driver_calendar_events" from "authenticated";

revoke truncate on table "public"."driver_calendar_events" from "authenticated";

revoke update on table "public"."driver_calendar_events" from "authenticated";

revoke delete on table "public"."driver_calendar_events" from "service_role";

revoke insert on table "public"."driver_calendar_events" from "service_role";

revoke references on table "public"."driver_calendar_events" from "service_role";

revoke select on table "public"."driver_calendar_events" from "service_role";

revoke trigger on table "public"."driver_calendar_events" from "service_role";

revoke truncate on table "public"."driver_calendar_events" from "service_role";

revoke update on table "public"."driver_calendar_events" from "service_role";

revoke delete on table "public"."driver_shifts" from "anon";

revoke insert on table "public"."driver_shifts" from "anon";

revoke references on table "public"."driver_shifts" from "anon";

revoke select on table "public"."driver_shifts" from "anon";

revoke trigger on table "public"."driver_shifts" from "anon";

revoke truncate on table "public"."driver_shifts" from "anon";

revoke update on table "public"."driver_shifts" from "anon";

revoke delete on table "public"."driver_shifts" from "authenticated";

revoke insert on table "public"."driver_shifts" from "authenticated";

revoke references on table "public"."driver_shifts" from "authenticated";

revoke select on table "public"."driver_shifts" from "authenticated";

revoke trigger on table "public"."driver_shifts" from "authenticated";

revoke truncate on table "public"."driver_shifts" from "authenticated";

revoke update on table "public"."driver_shifts" from "authenticated";

revoke delete on table "public"."driver_shifts" from "service_role";

revoke insert on table "public"."driver_shifts" from "service_role";

revoke references on table "public"."driver_shifts" from "service_role";

revoke select on table "public"."driver_shifts" from "service_role";

revoke trigger on table "public"."driver_shifts" from "service_role";

revoke truncate on table "public"."driver_shifts" from "service_role";

revoke update on table "public"."driver_shifts" from "service_role";

revoke delete on table "public"."order_history" from "anon";

revoke insert on table "public"."order_history" from "anon";

revoke references on table "public"."order_history" from "anon";

revoke select on table "public"."order_history" from "anon";

revoke trigger on table "public"."order_history" from "anon";

revoke truncate on table "public"."order_history" from "anon";

revoke update on table "public"."order_history" from "anon";

revoke delete on table "public"."order_history" from "authenticated";

revoke insert on table "public"."order_history" from "authenticated";

revoke references on table "public"."order_history" from "authenticated";

revoke select on table "public"."order_history" from "authenticated";

revoke trigger on table "public"."order_history" from "authenticated";

revoke truncate on table "public"."order_history" from "authenticated";

revoke update on table "public"."order_history" from "authenticated";

revoke delete on table "public"."order_history" from "service_role";

revoke insert on table "public"."order_history" from "service_role";

revoke references on table "public"."order_history" from "service_role";

revoke select on table "public"."order_history" from "service_role";

revoke trigger on table "public"."order_history" from "service_role";

revoke truncate on table "public"."order_history" from "service_role";

revoke update on table "public"."order_history" from "service_role";

revoke delete on table "public"."order_items" from "anon";

revoke insert on table "public"."order_items" from "anon";

revoke references on table "public"."order_items" from "anon";

revoke select on table "public"."order_items" from "anon";

revoke trigger on table "public"."order_items" from "anon";

revoke truncate on table "public"."order_items" from "anon";

revoke update on table "public"."order_items" from "anon";

revoke delete on table "public"."order_items" from "authenticated";

revoke insert on table "public"."order_items" from "authenticated";

revoke references on table "public"."order_items" from "authenticated";

revoke select on table "public"."order_items" from "authenticated";

revoke trigger on table "public"."order_items" from "authenticated";

revoke truncate on table "public"."order_items" from "authenticated";

revoke update on table "public"."order_items" from "authenticated";

revoke delete on table "public"."order_items" from "service_role";

revoke insert on table "public"."order_items" from "service_role";

revoke references on table "public"."order_items" from "service_role";

revoke select on table "public"."order_items" from "service_role";

revoke trigger on table "public"."order_items" from "service_role";

revoke truncate on table "public"."order_items" from "service_role";

revoke update on table "public"."order_items" from "service_role";

revoke delete on table "public"."order_rejections" from "anon";

revoke insert on table "public"."order_rejections" from "anon";

revoke references on table "public"."order_rejections" from "anon";

revoke select on table "public"."order_rejections" from "anon";

revoke trigger on table "public"."order_rejections" from "anon";

revoke truncate on table "public"."order_rejections" from "anon";

revoke update on table "public"."order_rejections" from "anon";

revoke delete on table "public"."order_rejections" from "authenticated";

revoke insert on table "public"."order_rejections" from "authenticated";

revoke references on table "public"."order_rejections" from "authenticated";

revoke select on table "public"."order_rejections" from "authenticated";

revoke trigger on table "public"."order_rejections" from "authenticated";

revoke truncate on table "public"."order_rejections" from "authenticated";

revoke update on table "public"."order_rejections" from "authenticated";

revoke delete on table "public"."order_rejections" from "service_role";

revoke insert on table "public"."order_rejections" from "service_role";

revoke references on table "public"."order_rejections" from "service_role";

revoke select on table "public"."order_rejections" from "service_role";

revoke trigger on table "public"."order_rejections" from "service_role";

revoke truncate on table "public"."order_rejections" from "service_role";

revoke update on table "public"."order_rejections" from "service_role";

revoke delete on table "public"."orders" from "anon";

revoke insert on table "public"."orders" from "anon";

revoke references on table "public"."orders" from "anon";

revoke select on table "public"."orders" from "anon";

revoke trigger on table "public"."orders" from "anon";

revoke truncate on table "public"."orders" from "anon";

revoke update on table "public"."orders" from "anon";

revoke delete on table "public"."orders" from "authenticated";

revoke insert on table "public"."orders" from "authenticated";

revoke references on table "public"."orders" from "authenticated";

revoke select on table "public"."orders" from "authenticated";

revoke trigger on table "public"."orders" from "authenticated";

revoke truncate on table "public"."orders" from "authenticated";

revoke update on table "public"."orders" from "authenticated";

revoke delete on table "public"."orders" from "service_role";

revoke insert on table "public"."orders" from "service_role";

revoke references on table "public"."orders" from "service_role";

revoke select on table "public"."orders" from "service_role";

revoke trigger on table "public"."orders" from "service_role";

revoke truncate on table "public"."orders" from "service_role";

revoke update on table "public"."orders" from "service_role";

revoke delete on table "public"."profiles" from "anon";

revoke insert on table "public"."profiles" from "anon";

revoke references on table "public"."profiles" from "anon";

revoke select on table "public"."profiles" from "anon";

revoke trigger on table "public"."profiles" from "anon";

revoke truncate on table "public"."profiles" from "anon";

revoke update on table "public"."profiles" from "anon";

revoke delete on table "public"."profiles" from "authenticated";

revoke insert on table "public"."profiles" from "authenticated";

revoke references on table "public"."profiles" from "authenticated";

revoke select on table "public"."profiles" from "authenticated";

revoke trigger on table "public"."profiles" from "authenticated";

revoke truncate on table "public"."profiles" from "authenticated";

revoke update on table "public"."profiles" from "authenticated";

revoke delete on table "public"."profiles" from "service_role";

revoke insert on table "public"."profiles" from "service_role";

revoke references on table "public"."profiles" from "service_role";

revoke select on table "public"."profiles" from "service_role";

revoke trigger on table "public"."profiles" from "service_role";

revoke truncate on table "public"."profiles" from "service_role";

revoke update on table "public"."profiles" from "service_role";

revoke delete on table "public"."user_roles" from "anon";

revoke insert on table "public"."user_roles" from "anon";

revoke references on table "public"."user_roles" from "anon";

revoke select on table "public"."user_roles" from "anon";

revoke trigger on table "public"."user_roles" from "anon";

revoke truncate on table "public"."user_roles" from "anon";

revoke update on table "public"."user_roles" from "anon";

revoke delete on table "public"."user_roles" from "authenticated";

revoke insert on table "public"."user_roles" from "authenticated";

revoke references on table "public"."user_roles" from "authenticated";

revoke select on table "public"."user_roles" from "authenticated";

revoke trigger on table "public"."user_roles" from "authenticated";

revoke truncate on table "public"."user_roles" from "authenticated";

revoke update on table "public"."user_roles" from "authenticated";

revoke delete on table "public"."user_roles" from "service_role";

revoke insert on table "public"."user_roles" from "service_role";

revoke references on table "public"."user_roles" from "service_role";

revoke select on table "public"."user_roles" from "service_role";

revoke trigger on table "public"."user_roles" from "service_role";

revoke truncate on table "public"."user_roles" from "service_role";

revoke update on table "public"."user_roles" from "service_role";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.audit_sensitive_access()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
BEGIN
  -- This function can be extended to log sensitive data access
  -- For now, it just validates the user is authenticated
  IF auth.uid() IS NULL THEN
    RAISE EXCEPTION 'Unauthorized access attempt to sensitive data';
  END IF;
  
  RETURN COALESCE(NEW, OLD);
END;
$function$
;

CREATE OR REPLACE FUNCTION public.check_all_drivers_rejected()
 RETURNS trigger
 LANGUAGE plpgsql
 SET search_path TO 'public'
AS $function$
DECLARE
  total_active_drivers INTEGER;
  total_rejections INTEGER;
BEGIN
  -- Count active drivers (those currently in shift)
  SELECT COUNT(DISTINCT driver_id) INTO total_active_drivers
  FROM public.driver_shifts 
  WHERE is_active = TRUE;
  
  -- Count rejections for this order
  SELECT COUNT(*) INTO total_rejections
  FROM public.orders 
  WHERE id = NEW.id 
    AND status = 'rejected' 
    AND rejected_by IS NOT NULL;
  
  -- If all active drivers have rejected this order, mark it as rejected
  IF total_rejections >= total_active_drivers AND total_active_drivers > 0 THEN
    UPDATE public.orders 
    SET status = 'rejected'
    WHERE id = NEW.id;
  END IF;
  
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.delete_auth_user()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
BEGIN
  -- This will be handled by the edge function instead
  -- Just return the old record for now
  RETURN OLD;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_driver_orders()
 RETURNS TABLE(id uuid, pickup_date date, pickup_time time without time zone, return_date date, return_time time without time zone, service_type text, service_name text, price numeric, status order_status, created_at timestamp with time zone, address text, first_name text, last_name text, phone text, driver_id uuid, user_id uuid)
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
BEGIN
  -- Check if user is a driver or admin
  IF NOT (has_role(auth.uid(), 'driver'::app_role) OR has_role(auth.uid(), 'admin'::app_role)) THEN
    RAISE EXCEPTION 'Access denied: Only drivers and admins can access this function';
  END IF;

  -- If admin, return all orders with full data
  IF has_role(auth.uid(), 'admin'::app_role) THEN
    RETURN QUERY
    SELECT 
      o.id,
      o.pickup_date,
      o.pickup_time,
      o.return_date,
      o.return_time,
      o.service_type,
      o.service_name,
      o.price,
      o.status,
      o.created_at,
      o.address,
      o.first_name,
      o.last_name,
      o.phone,
      o.driver_id,
      o.user_id
    FROM public.orders o
    ORDER BY o.created_at DESC;
    
    RETURN;
  END IF;

  -- For drivers: Return their assigned orders AND pending unassigned orders (if on shift)
  RETURN QUERY
  SELECT 
    o.id,
    o.pickup_date,
    o.pickup_time,
    o.return_date,
    o.return_time,
    o.service_type,
    o.service_name,
    o.price,
    o.status,
    o.created_at,
    -- Show full address for assigned orders, limited for pending
    CASE 
      WHEN o.driver_id = auth.uid() THEN o.address
      WHEN o.status = 'pending'::order_status AND o.driver_id IS NULL THEN 
        split_part(o.address, ',', 1) || ', [Osoite piilotettu kunnes hyväksytty]'
      ELSE o.address
    END as address,
    -- Show full name for assigned orders, limited for pending
    CASE 
      WHEN o.driver_id = auth.uid() THEN o.first_name
      WHEN o.status = 'pending'::order_status AND o.driver_id IS NULL THEN 'Asiakas'
      ELSE o.first_name
    END as first_name,
    CASE 
      WHEN o.driver_id = auth.uid() THEN o.last_name
      WHEN o.status = 'pending'::order_status AND o.driver_id IS NULL THEN ''
      ELSE o.last_name
    END as last_name,
    -- Show phone for assigned orders, hidden for pending
    CASE 
      WHEN o.driver_id = auth.uid() THEN o.phone
      WHEN o.status = 'pending'::order_status AND o.driver_id IS NULL THEN '[Piilotettu]'
      ELSE o.phone
    END as phone,
    o.driver_id,
    o.user_id
  FROM public.orders o
  WHERE 
    -- ALWAYS show orders assigned to this driver (regardless of shift status)
    o.driver_id = auth.uid() 
    OR 
    -- Show pending unassigned orders ONLY if driver is on active shift
    (o.status = 'pending'::order_status 
     AND o.driver_id IS NULL 
     AND EXISTS (
       SELECT 1 FROM public.driver_shifts 
       WHERE driver_shifts.driver_id = auth.uid() 
       AND is_active = true
     )
    )
  ORDER BY 
    CASE WHEN o.driver_id = auth.uid() THEN 0 ELSE 1 END, -- Assigned orders first
    o.created_at DESC;
    
END;
$function$
;

CREATE OR REPLACE FUNCTION public.handle_new_user()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
BEGIN
  INSERT INTO public.profiles (user_id, email, full_name)
  VALUES (
    NEW.id, 
    NEW.email, 
    COALESCE(NEW.raw_user_meta_data ->> 'full_name', NEW.raw_user_meta_data ->> 'name')
  );
  
  -- Only assign customer role if no role was manually assigned within 2 seconds
  -- This allows admin to create users with specific roles
  INSERT INTO public.user_roles (user_id, role)
  SELECT NEW.id, 'customer'
  WHERE NOT EXISTS (
    SELECT 1 FROM public.user_roles WHERE user_id = NEW.id
  );
  
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.has_role(_user_id uuid, _role app_role)
 RETURNS boolean
 LANGUAGE sql
 STABLE SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
  SELECT EXISTS (
    SELECT 1
    FROM public.user_roles
    WHERE user_id = _user_id
      AND role = _role
  )
$function$
;

CREATE OR REPLACE FUNCTION public.log_order_change(p_order_id uuid, p_change_type text, p_old_value jsonb DEFAULT NULL::jsonb, p_new_value jsonb DEFAULT NULL::jsonb, p_description text DEFAULT NULL::text)
 RETURNS uuid
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  history_id UUID;
BEGIN
  INSERT INTO public.order_history (
    order_id,
    changed_by,
    change_type,
    old_value,
    new_value,
    change_description
  ) VALUES (
    p_order_id,
    auth.uid(),
    p_change_type,
    p_old_value,
    p_new_value,
    p_description
  ) RETURNING id INTO history_id;
  
  RETURN history_id;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.log_order_creation()
 RETURNS trigger
 LANGUAGE plpgsql
 SET search_path TO 'public'
AS $function$
BEGIN
  PERFORM public.log_order_change(
    NEW.id,
    'created',
    NULL,
    row_to_json(NEW)::jsonb,
    'Tilaus luotu'
  );
  
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.log_order_status_change()
 RETURNS trigger
 LANGUAGE plpgsql
 SET search_path TO 'public'
AS $function$
BEGIN
  -- Log when status changes
  IF OLD.status IS DISTINCT FROM NEW.status THEN
    PERFORM public.log_order_change(
      NEW.id,
      'status_changed',
      jsonb_build_object('status', OLD.status),
      jsonb_build_object('status', NEW.status),
      'Tilauksen tila muuttui: ' || COALESCE(OLD.status::text, 'null') || ' -> ' || NEW.status::text
    );
  END IF;
  
  -- Log when driver is assigned
  IF OLD.driver_id IS DISTINCT FROM NEW.driver_id AND NEW.driver_id IS NOT NULL THEN
    PERFORM public.log_order_change(
      NEW.id,
      'accepted',
      jsonb_build_object('driver_id', OLD.driver_id),
      jsonb_build_object('driver_id', NEW.driver_id),
      'Kuljettaja hyväksyi tilauksen'
    );
  END IF;
  
  -- Log when pickup/return times are updated
  IF OLD.actual_pickup_time IS DISTINCT FROM NEW.actual_pickup_time 
     OR OLD.actual_return_time IS DISTINCT FROM NEW.actual_return_time
     OR OLD.pickup_date IS DISTINCT FROM NEW.pickup_date
     OR OLD.pickup_time IS DISTINCT FROM NEW.pickup_time
     OR OLD.return_date IS DISTINCT FROM NEW.return_date
     OR OLD.return_time IS DISTINCT FROM NEW.return_time THEN
    PERFORM public.log_order_change(
      NEW.id,
      'time_updated',
      jsonb_build_object(
        'pickup_date', OLD.pickup_date,
        'pickup_time', OLD.pickup_time,
        'return_date', OLD.return_date,
        'return_time', OLD.return_time,
        'actual_pickup_time', OLD.actual_pickup_time,
        'actual_return_time', OLD.actual_return_time
      ),
      jsonb_build_object(
        'pickup_date', NEW.pickup_date,
        'pickup_time', NEW.pickup_time,
        'return_date', NEW.return_date,
        'return_time', NEW.return_time,
        'actual_pickup_time', NEW.actual_pickup_time,
        'actual_return_time', NEW.actual_return_time
      ),
      'Nouto- tai palautusaikoja päivitettiin'
    );
  END IF;
  
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.log_time_changes()
 RETURNS trigger
 LANGUAGE plpgsql
 SET search_path TO 'public'
AS $function$
BEGIN
  -- Log pickup time changes
  IF OLD.pickup_date IS DISTINCT FROM NEW.pickup_date OR OLD.pickup_time IS DISTINCT FROM NEW.pickup_time THEN
    PERFORM public.log_order_change(
      NEW.id,
      'pickup_time_changed',
      jsonb_build_object(
        'pickup_date', OLD.pickup_date,
        'pickup_time', OLD.pickup_time
      ),
      jsonb_build_object(
        'pickup_date', NEW.pickup_date,
        'pickup_time', NEW.pickup_time
      ),
      'Noutohaarukka muutettu: ' || 
      COALESCE(OLD.pickup_date::text, 'null') || ' ' || COALESCE(OLD.pickup_time::text, 'null') || 
      ' -> ' || NEW.pickup_date::text || ' ' || NEW.pickup_time::text
    );
  END IF;
  
  -- Log return time changes
  IF OLD.return_date IS DISTINCT FROM NEW.return_date OR OLD.return_time IS DISTINCT FROM NEW.return_time THEN
    PERFORM public.log_order_change(
      NEW.id,
      'return_time_changed',
      jsonb_build_object(
        'return_date', OLD.return_date,
        'return_time', OLD.return_time
      ),
      jsonb_build_object(
        'return_date', NEW.return_date,
        'return_time', NEW.return_time
      ),
      'Palautushaarukka muutettu: ' || 
      COALESCE(OLD.return_date::text, 'null') || ' ' || COALESCE(OLD.return_time::text, 'null') || 
      ' -> ' || NEW.return_date::text || ' ' || NEW.return_time::text
    );
  END IF;
  
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_updated_at_column()
 RETURNS trigger
 LANGUAGE plpgsql
 SET search_path TO 'public'
AS $function$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.validate_data_access(table_name text, operation text)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
BEGIN
  -- Log access attempts for sensitive tables
  IF table_name IN ('profiles', 'orders', 'coupons', 'user_roles') THEN
    -- In production, this could log to an audit table
    RAISE LOG 'Access attempt to % table for % operation by user %', table_name, operation, auth.uid();
  END IF;
  
  -- Always return true for now (policies handle the actual restrictions)
  RETURN true;
END;
$function$
;


CREATE TRIGGER on_auth_user_created AFTER INSERT ON auth.users FOR EACH ROW EXECUTE FUNCTION handle_new_user();


